# java多线程
#### 1.线程的三种创建方式
- 继承Thread类,不推荐使用，因为java是但继承模式，限制比较多
- 实现Runnable接口，推荐使用
- 实现Callable接口,使用线程池，有返回值，会抛出异常，需要手动关闭。
#### 2.启动线程应使用start()方法，具体什么时间执行是由cpu决定的，不能直接调用run（）方法，直接调用run()方法，与调用普通方法没有区别，并不会启动一个新的线程
#### 3.静态代理模式。真实对象和代理对象都实现同一个接口，代理对象要代理真实角色。好处，代理对象可以做很多真实对象做不了的事情，真实对象专注与自己的事情
#### 4.Runnable是一个函数式接口，所以可以使用Lambda表达式
#### 5.线程的五大状态
- 创建状态
- 就绪状态
- 阻塞状态 调用sleep(),await()
- 运行状态
- 死亡状态 线程一旦进入死亡状态，就不能再次启动，再次启动会报错
#### 线程方法：
- setPriority(iint newPriority) 更改线程的优先级。
- static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠。
- void join() 等待该线程终止。
- static void yield() 暂停当前正在执行的线程对象，并执行其他线程。
- void interrupt() 中断线程，不推荐使用。
- boolean isAlive() 测试线程是否处于活动状态。
#### 停止线程，不推荐使用jdk提供的stop(),destroy()等方法，使用一个boolean 型的标志位通过改变标志位的状态来终止线程
#### 线程休眠：每一个对象都有一个锁，sleep不回释放锁。sleep可以模拟网络延时，倒计时等
#### 线程礼让：yeild礼让线程。让当前正在执行的线程暂停，但不阻塞。将线程从运行状态转为就绪状态，让cpu重新调度，礼让不一定成功，cpu有可能再次选择当前线程
#### Join 合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞，不推荐使用
#### 线程优先级：java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级调度哪个线程来执行。
#### 守护线程：daemon ，线程分为用户线程和守护线程，虚拟机必须确保用户线程执行完毕，虚拟机不用等待守护线程执行完毕，守护线程如后台记录操作日志，监控内存，垃圾回收等待。
#### 线程同步：线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕，下一个线程再使用，每个对象都有一个锁
#### 同步方法与同步块：同步方法synchronized 不需要传参数，默认锁的是当前对象。同步块synchronized(obj){}，其中obj是同步监视器。一般是用共享资源
#### 死锁：多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有两个以上对象的锁时，就可能会发生死锁的问题
#### Lock: 是显示锁（手动开启和关闭锁，一般放在finally中关闭）synchronized是隐式锁，出了作用域自动释放。Lock只有代码块锁，性能更好，JVM花费较少的时间来调度线程。优先使用Lock,其次使用同步代码块，最后使用同步方法
#### 生产者消费者问题：生产者 ——> 数据缓冲区 -> 消费者。需要用到线程间通信
- wait() 表示线程一直等待，直到其他线程通知，与sleep不通，会释放锁
- wait(long timeout)指定等待的毫秒数
- notify()唤醒一个处于等待状态的线程
- notifyAll()唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先调度
#### 解决生产消费问题方法一：利用缓冲区，名叫管程法，第二种是信号灯法
#### 线程池，看一下源码


