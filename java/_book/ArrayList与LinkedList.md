# ArrayList与LinkedList
### ArrayList 
##### 1.为什么位运算效率会更高
底层都是二进制进行计算的，jdk中很多都是使用位运算进行操作的
##### 2.集合的扩容
(1).容量:当初始容量不能满足需求时，会对集合进行扩容，如果需求没有大于当前容量+ 当前容量的一半时，会扩容为它，如果大于就给需求指定的容量
(2).操作:重新生成一个指定长度的数组，然后将当前数组的数据进行拷贝过去。
##### 3.集合初始化
有两个构造函数，不指定容量的会初始化一个默认的容量为10的数组，指定容量时，会初始化一个指定容量长度的数组
##### 4.集合的size
集合的size跟其使用的数组长度没有关系，size在调用add()方法的时候会进行增加，在调用remove方法的时候会进行减少
##### 5.线程安全性
线程不安全
### LinkedList
#### 1.底层实现
底层使用双向链表，Node节点
#### 2.成员变量有三个
size: 链表的数量
first: 链表的第一个节点
last: 链表的最后一个节点
存储链表的头节点和最后一个节点，用于，当我们需要以索引来查找节点的时候，我们可以根据index和size/2的大小，来决定从头查找还是从尾部查找，用来弥补单链表数据结构的缺点。
#### 3.线程安全性
是非线程安全的，如果想保证线程安全的前提下操作 LinkedList，可以使用 List list = Collections.synchronizedList(new LinkedList(...)); 来生成一个线程安全的 LinkedList
