# 总结
### 什么是JVM
java程序的运行环境，好处：一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态，重点部分：Java字节码，ClassLoader，方法区，堆，虚拟机栈，程序计数器，本地方法栈，解释器，即时编译器，垃圾回收，本地方法接口。
### 1.内存结构
* 程序计数器：作用是记住下一条JVM指令的执行地址，线程私有，不会存在内存溢出
* 虚拟机栈：每个线程运行时所需要的内存，称为虚拟机栈，每个栈由多个栈帧组成，对应着每次方法调用所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法
* 本地方法栈：一些native方法的调用需用的内存
* 堆：通过new关键字，创建对象都会使用堆内存，它是线程共享的，堆中对象需要考虑线程安全的问题，有垃圾回收机制
* 方法区：主要放置Class，ClassLoader，与常量池。1.6之前，使用永久代实现，把StringTable放在了常量池中，后面的结构，使用元空间实现，整个方法区，放进了本地内存中，并且StringTable放进了堆区中，方便垃圾回收。  
   * 运行时常量池：常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量 等信息。运行时常量池，常量池是 .class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量 池，并把里面的符号地址变为真实地址  
   * 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder （1.8） 字符串常量拼接的原理是编译期优化 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池  
      * 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回  
      * 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份， 放入串池， 会把串池中的对象返回

### 2.垃圾回收
* 如何判断对象可以回收  
采用可达性分析来探索错有存活的对象，扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收
* 垃圾回收算法
分三种：标记清除(缺点会导致大量的内存碎片)，标记整理(缺点速度慢)，拷贝(缺点会占用双倍内存空间)
* 分代垃圾回收
对象首先分配在伊甸园区域，新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to，minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行，当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit），当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时 间更长
* 垃圾回收器
垃圾回收器分为，串型，吞吐量优先，响应时间优先，G1现在jvm使用的垃圾回收器，适用场景：同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms，超大堆内存，会将堆划分为多个大小相等的 Region，整体上是 标记+整理 算法，两个区域之间是 复制 算法
* 垃圾回收调优
### 3.类加载与字节码技术
#### (1).类文件结构
```java
ClassFile {

u4 magic;
u2 minor_version;
u2 major_version;
u2 constant_pool_count; 
cp_info constant_pool[constant_pool_count-1]; 
u2 access_flags; 
u2 this_class; 
u2 super_class; 
u2 interfaces_count; 
u2 interfaces[interfaces_count]; 
u2 fields_count; 
field_info fields[fields_count]; 
u2 methods_count; 
method_info methods[methods_count]; 
u2 attributes_count; 
attribute_info attributes[attributes_count];

}

```
* 魔数：0~3 字节，表示它是否是【class】类型的文件
* 版本: 4~7 字节，表示类的版本 00 34（52） 表示是 Java 8
* 常量池： 
* 访问标识与继承信息
* Field 信息表示成员变量数量，本类为 0
* Method 信息表示方法数量，本类为 2
* 附加属性

#### (2).字节码指令
自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件;
#### (3).编译器处理
所谓的 语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃 嘛）
#### (4).类加载阶段
* 加载：将类的字节码载入方法区中，内部采用C++的instanceKlass描述java类，如果这个类还有父类没有加载，先加载父类，加载和链接可能交替运行
* 链接：验证类是否符合JVM规范，安全性检查，准备为static变量分配空间，设置默认值，解析，将常量池中的符号引用解析为直接引用。
* 初始化：即调用<cinit>()v,虚拟机会保证这个类的构造方法的线程安全
#### (5).类加载器
* Bootstrap ClassLoader
* Extention ClassLoader 上级为Bootstrap，显示为null
* Application ClassLoader 上级为Extension
* 自定义类加载器 上级为Application
#### (6).运行期优化
* JVM 将执行状态分成了 5 个层次：
0 层，解释执行（Interpreter） 1 层，使用 C1 即时编译器编译执行（不带 proﬁling） 2 层，使用 C1 即时编译器编译执行（带基本的 proﬁling） 3 层，使用 C1 即时编译器编译执行（带完全的 proﬁling） 4 层，使用 C2 即时编译器编译执行
* 即时编译器（JIT）与解释器的区别
解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需 再编译 解释器是将字节码解释为针对所有平台都通用的机器码 JIT 会根据平台类型，生成平台特定的机器码
### 4.内存模型
#### (1)java内存模型
JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障 原子性，使用synchronized关键字保持操作的原子性
#### (2)可见性
使用volatile关键字修饰即可保证可见性。因为线程要频繁的从主内存中读取参数的值，JIT编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存的访问，提高效率。volatile：它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到 主存中获取它的值，线程操作 volatile 变量都是直接操作主存
#### (3)有序性
JVM 会在不影响正确性的前提下，可以调整语句的执行顺序。这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性
#### (4)CAS与原子类
它体现的一种乐观锁的思想
```java
// 需要不断尝试 
while(true) {

int 旧值 = 共享变量 ; // 比如拿到了当前值 0 
int 结果 = 旧值 + 1; // 在旧值 0 的基础上增加 1 ，正确结果是 1

/*

这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候 compareAndSwap 返回 false，重新尝试，直到： compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰 */ 
if( compareAndSwap ( 旧值, 结果 )) { // 成功，退出循环 }

}
```
需要volatile关键字修饰
* 乐观锁与悲观锁：CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。 synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会
* 原子操作类：juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、 AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的
#### (5)synchronized 优化
