# 协程基础
#### 协程相关 关键字与概念
- GlobalScope 全局协程作用域，在其中启动的活动协程并不会使进程包活，就像守护线程。
- CoroutineScope 创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束，挂起函数
- runBlocking 作用与CoroutineScope 类似，区别是它是线程阻塞的，常规函数
- launch
- job
- 结构化的并发
##### 取消与超时
- 取消是协作的 （如果协程正在执行计算任务，并且没有检查取消，那么它是不能被取消的）
- isActive 一个扩展属性，用于显示的检查取消状态
- 通常使用try finally 表达式来处理在被取消时抛出的CancellationException异常
```bash
val job = launch {

	try { 
		repeat(1000) { 
			i -> println("job: I'm sleeping $i ...") 
			delay(500L) 
			} 
	} finally { 
		println("job: I'm running finally") }

}
```
- 运行不能取消的代码块，在finally块中调用挂起函数的行为都会抛出CancellationException,可以使用withContext(NonCancellable){}处理
```bash
val job = launch {

	try { 
		repeat(1000) { 
			i -> println("job: I'm sleeping $i ...") 
			delay(500L) 
			}
	    } finally {
	    	withContext(NonCancellable) { 
			println("job: I'm running finally") 
			delay(1000L) 
			println("job: And I've just delayed for 1 sec because I'm non-cancellable")
			}
	     }

}
```
#### 组合挂起函数
- 挂起函数默认是顺序调用的，如需并发调用，可以使用async
- 惰性启动,只有结果 通过 await 获取的时候协程才会启动，或者在 Job 的 start 函数调⽤的时候,只调用await,不会并行执行，只有调用了start方法后才会并发执行
```bash
val time = measureTimeMillis {

	val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }
	val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }
	// 执⾏⼀些计算 
	one.start() // 启动第⼀个 
	two.start() // 启动第⼆个 
	println("The answer is ${one.await() + two.await()}")

}
```
