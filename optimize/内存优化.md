# 内存优化
### 内存是什么
后面有时间再去深入研究
### jvm是怎么处理的
后面有时间再去深入研究
1）、方法区：存储类信息、常量、静态变量等。=> 所有线程共享
2）、虚拟机栈：存储局部变量表、操作数栈等。
3）、本地方法栈：不同与虚拟机栈为 Java 方法服务、它是为 Native 方法服务的。
4）、堆：内存最大的区域，每一个对象实际分配内存都是在堆上进行分配的，，而在虚拟机栈中分配的只是引用，这些引用会指向堆中真正存储的对象。此外，堆也是垃圾回收器（GC）所主要作用的区域，并且，内存泄漏也都是发生在这个区域。=> 所有线程共享
5）、程序计数器：存储当前线程执行目标方法执行到了第几行。
### Android内存这一块的独有特点
### 内存优化方向
每个进程所分配的内容都是有最大限制的，内存如果过多会造成gc，或者oom。gc主要是Full GC在堆内存一些内存区域被写满时就可能会导致GC，GC只是对不再使用的内存区域进行回收，当申请的内存都不能回收且超过了分配内存的最大值就会导致oom
#### (1).内存泄漏导致
内存泄漏的检测，通过Androidstudio自带的Profile MEMORY去查看，反复的打开和关闭页面，如果total内存没有恢复到之前的数值，则可能发生内存泄漏，然后去查看堆栈信息，找到对应的activity，如果引用了多个实例，则表明发生了内存泄漏
##### 常见的内存泄漏(Android相关的一般都是context导致，归根结底都是长生命周期对象，引用了短生命周期的对象)
* handler导致
* 单例模式造成，context尽量使用Application 的context，如果使用Activity的context应该使用弱引用， 
#### (2).做到能少则少使用内存
* 对象引用，对于一些与activity生命周期管理的对象的引用，当需要引用它的时候，尽量使用弱引用，这样，在系统触发gc的时候可以将其回收
* 自动装箱问题，比如HashMap的存储，键值对都是object，在使用int作为键的时候，会自动将其装箱成integer，造成不必要的浪，Integer对象有16个字节，int只有4字节
* 使用Android系统提供的优化形式 SpareArray，SparseBooleanArray，LongSparseArray
* 避免创作不必要的对象，例如我们可以在字符串拼接的时候使用StringBuffer，StringBuilder
